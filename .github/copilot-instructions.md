# Copilot Instructions for punkte_spiel

- Purpose: grid-based two-player (human vs. computer) strategy prototype using Tkinter; entrypoint `src/main.py` starts `StrategieSpiel` and Tk mainloop.
- Architecture: `controllers/spiel.StrategieSpiel` wires the UI (`gui.game_canvas.GameCanvas`, `gui.buttons.ButtonPanel`, `gui.labels.ResourceLabel`), kicks off resource manager, initializes grid/state, and handles end-turn/end-round actions. Older sandbox logic lives in `src/controllers/strategie_spiel.py` and should generally be avoided.
- Global state: `config.py` holds most game data as class-level attributes (Game, GameGrid, GameCanvas, Player, Building, BuildingMenu, Design). Mutate these shared objects directly when updating state.
- Grid model: `config.GameGrid.fields` is the canonical board map keyed by `(col, row)` with keys `rect_id`, `building`, `player`, `persistent_color`, `connections`. Keep canvas drawings (`canvas_utils.draw.*`) and this dict in sync on placement/removal.
- Turn/round flow: `game_state_utils.next_turn` toggles `Game.current_turn` and optionally increments `Game.round_number`. `StrategieSpiel.end_turn` calls `next_turn`; `end_round` calls `next_turn` then `economy_manager.add_ressources`, then refresh labels via `window_utils.update_widgets`.
- Economy: Costs scale with existing building count and inflation (`Game.inflation_rate`) via `economy_manager.calculate_building_cost`; maintenance/upgrade helpers live in the same module. `pay_building` deducts from the active player; per-round income sits on `config.Player.*.ressources_per_round`.
- Building placement: `GameCanvas.on_click` sets `config.GameCanvas.selected_field` then opens menus based on `fields[(col,row)]["player"]` and `building` id. `gui/menus/building_menu.py` renders available options, colors cells red/normal based on affordability, and invokes `identify_utils.execute_function_by_building_id`.
- Drawing + state update: models (`models/dorf.py`, `ressourcenproduktion.py`, `stadt.py`) draw via `canvas_utils.draw.*`, flip `GameCanvas.is_field_selected` off, write `fields[(col,row)]["building"|"player"]`, clear the highlight, charge the player, occupy neighboring cells, and increment the relevant player counters. Mirror this for new placeable types.
- Streets: Selecting “Straße” enters street placing mode (`Street.start_street_placing_mode`). Clicks set start/end fields; previews live in `Building.Street.preview_streets` and are drawn with `canvas_utils.draw.draw_road`. `Street.end_street_placing_mode` charges aggregated cost (`pay_building(..., number=len(preview_streets))`), calls `occupy_area`, records streets on the player, and removes the temporary buttons; `cancel_street_placing_mode` must clear preview lines and reset state.
- Home placement: `Home.mark_available_area_for_home` gates placement zones; `Home.place_home` sets `Building.Home.left_player/right_player`, draws a city icon, marks occupancy, clears highlights, and advances the turn without ending the round.
- Canvas helpers: prefer `canvas_utils.highlight_field`, `persistent_highlight_field`, `clear_field/clear_all_fields`, `transparently_highlight_field` over raw color changes to keep `persistent_color` consistent.
- GUI layout: root grid configured via `utils/layout_utils.init_grid`. Buttons live in `ButtonPanel` (row 1 controls turn/round; row 2 used for street confirm/cancel). Resource labels (`gui/labels.py`) read `config.Player.*.ressources`; call `window_utils.update_widgets` after changing resources.
- Coordinates: `grid_utils.get_grid_coordinates` translates pixel clicks to `(col,row)`; `identify_utils.get_neighbor_coordinates`/`is_neighbour` handle adjacency. Store/compare positions in `(col, row)` order everywhere.
- Running/debugging: requires Tkinter (standard with CPython). From repo root run `python src/main.py` to launch the UI. No automated tests are present; verify manually by exercising building placement, turn toggling, resource updates, and street confirmation/cancellation.
- Gotchas: reset `GameCanvas.selected_field`/`is_field_selected` after handling a click; ensure resource deductions happen once per action (`pay_building`); keep player building counters (`number_of_*`) aligned with placements; preserve `config.Building` flags like `Street.street_placing_mode` and `Home.place_home_mode` when altering flows.
- Branches: follow `docs/BRANCH_GUIDELINES.md` (main/develop; prefixes feat/, fix/, hotfix/, release/) and keep branches rebased with base.
- Commits: follow `docs/COMMIT_GUIDELINES.md` (`<type>(<scope>): <summary>` in imperative; allowed types feat/fix/docs/style/refactor/test/chore; add why/impact in body if non-trivial).
- PRs: follow `docs/PULL_REQUEST_GUIDELINES.md` (imperative titles, describe what/why/testing, target correct base, ensure comments resolved before merge).
